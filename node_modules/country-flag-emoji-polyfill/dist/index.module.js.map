{"version":3,"file":"index.module.js","sources":["../src/emoji.ts","../src/index.ts"],"sourcesContent":["// emoji detection code inspired by if-emoji and emoji-picker-element, with modifications.\r\nconst FONT_FAMILY =\r\n  '\"Twemoji Mozilla\",\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",' +\r\n  '\"Noto Color Emoji\",\"EmojiOne Color\",\"Android Emoji\",sans-serif';\r\n\r\nfunction makeCtx() {\r\n  const canvas = document.createElement(\"canvas\");\r\n  canvas.width = canvas.height = 1;\r\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true })!;\r\n  ctx.textBaseline = \"top\";\r\n  ctx.font = `100px ${FONT_FAMILY}`;\r\n  ctx.scale(0.01, 0.01);\r\n  return ctx;\r\n}\r\n\r\nfunction getColor(ctx: CanvasRenderingContext2D, text: string, color: string) {\r\n  // we're rendering to a 1px canvas so it'll be a character (or, hopefully, a\r\n  // color emoji) scaled down to a single vague brownish pixel\r\n  ctx.clearRect(0, 0, 100, 100);\r\n  ctx.fillStyle = color;\r\n  ctx.fillText(text, 0, 0);\r\n\r\n  const bytes = ctx.getImageData(0, 0, 1, 1).data;\r\n  return bytes.join(\",\");\r\n}\r\n\r\n/**\r\n * Detects whether the emoji in `text` is rendered as a color emoji by this\r\n * browser.\r\n *\r\n * Note: this is not complete for detecting support for any emoji. Notably, it\r\n * does not detect whether emojis that consist of two glyphs with a\r\n * zero-width-joiner are rendered as a single emoji or as two, because this is\r\n * not needed to detect country flag support.\r\n */\r\nexport function supportsEmoji(text: string) {\r\n  // Render `text` to a single pixel in white and in black, and then compare\r\n  // them to each other and ensure they're the same color, and neither one is\r\n  // black. This shows that the emoji was rendered in color, and the font color\r\n  // was disregarded.\r\n  const ctx = makeCtx();\r\n  const white = getColor(ctx, text, \"#fff\");\r\n  const black = getColor(ctx, text, \"#000\");\r\n\r\n  // This is RGBA, so for 0,0,0, we are checking that the first RGB is not all zeroes.\r\n  // Most of the time when unsupported this is 0,0,0,0, but on Chrome on Mac it is\r\n  // 0,0,0,61 - there is a transparency here.\r\n  return black === white && !black.startsWith(\"0,0,0,\");\r\n}\r\n","import { supportsEmoji } from \"./emoji\";\n\n/**\n * Injects a style element into the HEAD with a web font with country flags,\n * iff the browser does support emojis but not country flags.\n *\n * @param fontName - Override the default font name (\"Twemoji Country Flags\")\n * @param fontUrl - Override the font URL (defaults to a jsdeliver-hosted)\n *\n * @returns true if the web font was loaded (ie the browser does not support country flags)\n */\nexport function polyfillCountryFlagEmojis(\n  fontName = \"Twemoji Country Flags\",\n  fontUrl = \"https://cdn.jsdelivr.net/npm/country-flag-emoji-polyfill@0.1/dist/TwemojiCountryFlags.woff2\"\n) {\n  if (supportsEmoji(\"ðŸ˜Š\") && !supportsEmoji(\"ðŸ‡¨ðŸ‡­\")) {\n    const style = document.createElement(\"style\");\n\n    // I generated the `unicode-range` below using\n    // https://wakamaifondue.com/beta/, which is awesome and it helps make sure\n    // this font is never tried for any character that it does not support.\n    //\n    // See build/make-font.sh for more background why these are the relevant\n    // unicode ranges.\n    //\n    // Also, we're setting `font-display` to \"swap\" because without it, all text\n    // will be invisible during the time between this style tag being injected\n    // and the font having been loaded. This happens because developers will\n    // typically set `Twemoji Country Flags` as the first font in their\n    // `font-family` lists, and the browser tries to prevent a \"flash of\n    // unstyled text\" and therefore hide all text instead of rendering it with\n    // potentially the wrong font. This matters when you're waiting for Open\n    // Sans to load and you dont want your blog to briefly render in Times New\n    // Roman first, but it's actively harmful for apps, where text might briefly\n    // disappear just to load some country flag fallbacks that might not even be\n    // on the page.\n    //\n    // Apparently (when I tested this) browsers aren't smart enough to only do\n    // hide characters that match the not-yet-loaded font's unicode-range.\n    // Setting it to \"swap\" unfortunately makes the browser render eg `â–¡` or\n    // `É´ÊŸ` for country flags until the font is in. But this is way better than\n    // hiding all UI text everywhere :D\n    style.textContent = `@font-face {\n      font-family: \"${fontName}\";\n      unicode-range: U+1F1E6-1F1FF, U+1F3F4, U+E0062-E0063, U+E0065, U+E0067,\n        U+E006C, U+E006E, U+E0073-E0074, U+E0077, U+E007F;\n      src: url('${fontUrl}') format('woff2');\n      font-display: swap;\n    }`;\n    document.head.appendChild(style);\n\n    return true;\n  }\n  return false;\n}\n"],"names":["getColor","ctx","text","color","clearRect","fillStyle","fillText","getImageData","data","join","supportsEmoji","canvas","document","createElement","width","height","getContext","willReadFrequently","textBaseline","font","scale","makeCtx","white","black","startsWith","polyfillCountryFlagEmojis","fontName","fontUrl","style","textContent","head","appendChild"],"mappings":"AAeA,SAASA,EAASC,EAA+BC,EAAcC,GAQ7D,OALAF,EAAIG,UAAU,EAAG,EAAG,IAAK,KACzBH,EAAII,UAAYF,EAChBF,EAAIK,SAASJ,EAAM,EAAG,GAERD,EAAIM,aAAa,EAAG,EAAG,EAAG,GAAGC,KAC9BC,KAAK,KAYd,SAAUC,EAAcR,GAK5B,IAAMD,EAnCR,WACE,IAAMU,EAASC,SAASC,cAAc,UACtCF,EAAOG,MAAQH,EAAOI,OAAS,EAC/B,IAAMd,EAAMU,EAAOK,WAAW,KAAM,CAAEC,oBAAoB,IAI1D,OAHAhB,EAAIiB,aAAe,MACnBjB,EAAIkB,KAAJ,gJACAlB,EAAImB,MAAM,IAAM,KACTnB,EA4BKoB,GACNC,EAAQtB,EAASC,EAAKC,EAAM,QAC5BqB,EAAQvB,EAASC,EAAKC,EAAM,QAKlC,OAAOqB,IAAUD,IAAUC,EAAMC,WAAW,UCpC9BC,SAAAA,EACdC,EACAC,GAEA,QAFuG,IADvGD,IAAAA,EAAW,8BAC4F,IAAvGC,IAAAA,EAAU,+FAENjB,EAAc,QAAUA,EAAc,QAAS,CACjD,IAAMkB,EAAQhB,SAASC,cAAc,SAmCrC,OATAe,EAAMC,YACYH,qCAAAA,EAGJC,mKAAAA,EAGdf,wDAAAA,SAASkB,KAAKC,YAAYH,IAG3B,EACD,OACD"}